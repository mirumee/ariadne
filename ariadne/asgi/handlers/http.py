import asyncio
import json
import logging
from asyncio import Lock
from functools import partial
from http import HTTPStatus
from inspect import isawaitable
from io import StringIO
from typing import (
    Any,
    Optional,
    cast,
    Dict,
    AsyncGenerator,
    Callable,
    Awaitable,
    Literal,
    get_args,
    List,
    Union,
)
from typing import Type

from anyio import (
    get_cancelled_exc_class,
    CancelScope,
    sleep,
    move_on_after,
    create_task_group,
)
from graphql import DocumentNode
from graphql import MiddlewareManager
from starlette.datastructures import UploadFile
from starlette.requests import Request
from starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse
from starlette.responses import Response
from starlette.types import Receive, Scope, Send

from .base import GraphQLHttpHandlerBase
from ... import format_error
from ...constants import (
    DATA_TYPE_JSON,
    DATA_TYPE_MULTIPART,
)
from ...exceptions import HttpBadRequestError
from ...exceptions import HttpError
from ...explorer import Explorer
from ...file_uploads import combine_multipart_data
from ...graphql import (
    ExecutionResult,
    GraphQLError,
    parse_query,
    subscribe,
    validate_data,
)
from ...graphql import graphql
from ...logger import log_error
from ...types import (
    ContextValue,
    ExtensionList,
    Extensions,
    GraphQLResult,
    MiddlewareList,
    Middlewares,
)

EVENT_TYPES = Literal["next", "complete"]


class GraphQLServerSentEvent:
    """GraphQLServerSentEvent is a class that represents a single Server-Sent Event
    as defined in the GraphQL SSE Protocol specification
    (https://github.com/enisdenjo/graphql-sse/blob/master/PROTOCOL.md)
    """

    DEFAULT_SEPARATOR = "\r\n"

    def __init__(
        self,
        event: EVENT_TYPES,
        result: Optional[ExecutionResult] = None,
    ):
        """Initializes the Server-Sent Event
        # Required arguments
        `event`: the type of the event. Either "next" or "complete"

        # Optional arguments
        `result`: an `ExecutionResult` or a `dict` that represents the result of the operation
        """
        assert event in get_args(EVENT_TYPES), f"Invalid event type: {event}"
        self.event = event
        self.result = result
        self.logger = logging.Logger("GraphQLServerSentEvent")

    def _write_to_buffer(
        self, buffer: StringIO, name: str, value: Optional[str]
    ) -> StringIO:
        """Writes a SSE field to the buffered SSE event representation

        Returns the `StringIO` buffer with the field written to it

        # Required arguments
        `buffer`: the `StringIO` buffer to write to
        `name`: the name of the field
        `value`: the value of the field
        """
        if value is not None:
            buffer.write(f"{name}: {value}{self.DEFAULT_SEPARATOR}")
        return buffer

    def encode_execution_result(self) -> str:
        """Encodes the execution result into a single line JSON string

        Returns the JSON string representation of the execution result
        """
        payload: Dict[str, Any] = {}
        if self.result.data:
            payload["data"] = self.result.data
        if self.result.errors:
            errors = []
            for error in self.result.errors:
                log_error(error, self.logger)
                errors.append(format_error(error))
            payload["errors"] = errors

        return json.dumps(payload)

    def __str__(self) -> str:
        """Returns the string representation of the Server-Sent Event"""
        buffer = StringIO()
        buffer = self._write_to_buffer(buffer, "event", self.event)
        buffer = self._write_to_buffer(
            buffer,
            "data",
            (
                self.encode_execution_result()
                if self.event == "next" and self.result
                else ""
            ),
        )
        buffer.write(self.DEFAULT_SEPARATOR)

        return buffer.getvalue()


class ServerSentEventResponse(Response):
    """Sends GraphQL SSE events using EvenSource protocol using Starlette's Response class
    based on the implementation https://github.com/sysid/sse-starlette/
    """

    # Sends a ping event to the client every 15 seconds to overcome proxy timeout issues
    DEFAULT_PING_INTERVAL = 15

    def __init__(
        self,
        generator: AsyncGenerator[GraphQLServerSentEvent, Any],
        send_timeout: Optional[int] = None,
        ping_interval: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
        encoding: Optional[str] = None,
        *args,
        **kwargs,
    ):
        """Initializes the a SSE Response that send events generated by an async generator

        # Required arguments
        `generator`: an async generator that yields `GraphQLServerSentEvent` objects

        # Optional arguments
        `send_timeout`: the timeout in seconds to send an event to the client
        `ping_interval`: the interval in seconds to send a ping event to the client, overrides
        the DEFAULT_PING_INTERVAL of 15 seconds
        `headers`: a dictionary of headers to be sent with the response
        `encoding`: the encoding to use for the response
        """
        super().__init__(*args, **kwargs)
        self.generator = generator
        self.status_code = HTTPStatus.OK
        self.send_timeout = send_timeout
        self.ping_interval = ping_interval or self.DEFAULT_PING_INTERVAL
        self.encoding = encoding or "utf-8"
        self.content = None

        _headers: dict[str, str] = {}
        if headers is not None:
            _headers.update(headers)
        # mandatory for servers-sent events headers
        # allow cache control header to be set by user to support fan out proxies
        # https://www.fastly.com/blog/server-sent-events-fastly
        _headers.setdefault("Cache-Control", "no-cache")
        _headers.setdefault("Connection", "keep-alive")
        _headers.setdefault("X-Accel-Buffering", "no")
        _headers.setdefault("Transfer-Encoding", "chunked")
        self.media_type = "text/event-stream"
        self.init_headers(_headers)

        self._send_lock = Lock()

    @staticmethod
    async def listen_for_disconnect(receive: Receive) -> None:
        """Listens for the client disconnect event and stops the streaming by exiting the infinite loop
        this triggers the anyio CancelScope to cancel the TaskGroup

        # Required arguments
        `receive`: the starlette Receive object
        """
        while True:
            message = await receive()
            if message["type"] == "http.disconnect":
                logging.debug(f"Got event: http.disconnect. Stop streaming...")
                break

    def encode_event(self, event: GraphQLServerSentEvent) -> bytes:
        """Encodes the GraphQLServerSentEvent into a bytes object

        # Required arguments
        `event`: the GraphQLServerSentEvent object
        """
        return str(event).encode(self.encoding)

    async def _ping(self, send: Send) -> None:
        """Sends a ping event to the client every `ping_interval` seconds gets cancelled if the client disconnects
        through the anyio CancelScope of the TaskGroup

        # Required arguments
        `send`: the starlette Send object
        """
        while True:
            await sleep(self.ping_interval)
            async with self._send_lock:
                await send(
                    {
                        "type": "http.response.body",
                        "body": self.encode_event(GraphQLServerSentEvent(event="next")),
                        "more_body": True,
                    }
                )

    async def send_events(self, send: Send) -> None:
        """Sends the events generated by the async generator to the client

        # Required arguments
        `send`: the starlette Send object

        """
        async with self._send_lock:
            await send(
                {
                    "type": "http.response.start",
                    "status": self.status_code,
                    "headers": self.raw_headers,
                }
            )

        try:
            async for event in self.generator:
                async with self._send_lock:
                    with move_on_after(self.send_timeout) as timeout:
                        await send(
                            {
                                "type": "http.response.body",
                                "body": self.encode_event(event),
                                "more_body": True,
                            }
                        )

                    if timeout.cancel_called:
                        raise asyncio.TimeoutError()

        except (get_cancelled_exc_class(),) as e:
            logging.warning(e)
        finally:
            with CancelScope(shield=True):
                async with self._send_lock:
                    await send(
                        {"type": "http.response.body", "body": b"", "more_body": False}
                    )

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """The main entrypoint for the ServerSentEventResponse which is called by starlette

        # Required arguments
        `scope`: the starlette Scope object

        `receive`: the starlette Receive object

        `send`: the starlette Send object

        """
        async with create_task_group() as task_group:

            async def wrap_cancelling(func: Callable[[], Awaitable[None]]) -> None:
                await func()
                task_group.cancel_scope.cancel()

            task_group.start_soon(wrap_cancelling, partial(self._ping, send))
            task_group.start_soon(wrap_cancelling, partial(self.send_events, send))
            # this will cancel the task group when the client disconnects
            await wrap_cancelling(partial(self.listen_for_disconnect, receive))


class GraphQLHTTPHandler(GraphQLHttpHandlerBase):
    """Default ASGI handler for HTTP requests.

    Supports the `Query` and `Mutation` operations.
    """

    def __init__(
        self,
        extensions: Optional[Extensions] = None,
        middleware: Optional[Middlewares] = None,
        middleware_manager_class: Optional[Type[MiddlewareManager]] = None,
    ) -> None:
        """Initializes the HTTP handler.

        # Optional arguments

        `extensions`: an `Extensions` list or callable returning a
        list of extensions server should use during query execution. Defaults
        to no extensions.

        `middleware`: a `Middlewares` list or callable returning a list of
        middlewares server should use during query execution. Defaults to no
        middlewares.

        `middleware_manager_class`: a `MiddlewareManager` type or subclass to
        use for combining provided middlewares into single wrapper for resolvers
        by the server. Defaults to `graphql.MiddlewareManager`. Is only used
        if `extensions` or `middleware` options are set.
        """
        super().__init__()

        self.extensions = extensions
        self.middleware = middleware
        self.middleware_manager_class = middleware_manager_class or MiddlewareManager

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        """An entrypoint for the GraphQL HTTP handler.

        This method is called by the Ariadne ASGI GraphQL application to execute
        queries done using the HTTP protocol.

        It creates the `starlette.requests.Request` instance, calls
        `handle_request` method with it, then sends response back to the client.

        # Required arguments

        `scope`: The connection scope information, a dictionary that contains
        at least a type key specifying the protocol that is incoming.

        `receive`: an awaitable callable that will yield a new event dictionary
        when one is available.

        `send`: an awaitable callable taking a single event dictionary as a
        positional argument that will return once the send has been completed
        or the connection has been closed.

        Details about the arguments and their usage are described in the
        ASGI specification:

        https://asgi.readthedocs.io/en/latest/specs/main.html
        """
        request = Request(scope=scope, receive=receive)
        response = await self.handle_request(request)
        await response(scope, receive, send)

    async def handle_request(self, request: Request) -> Response:
        """Handle GraphQL request and return response for the client.

        Is called by the `handle` method and `handle_request` method of the
        ASGI GraphQL application.

        Handles three HTTP methods:

        `GET`: returns GraphQL explorer or 405 error response if explorer or
        introspection is disabled.

        `POST`: executes the GraphQL query from either `application/json` or
        `multipart/form-data` requests.

        `OPTIONS`: returns supported HTTP methods.

        Returns Starlette's `Response` instance, which is also works in FastAPI.

        # Required arguments:

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        if request.method == "GET":
            if self.execute_get_queries and request.query_params.get("query"):
                return await self.graphql_http_server(request)
            if self.introspection and self.explorer:
                # only render explorer when introspection is enabled
                return await self.render_explorer(request, self.explorer)

        if request.method == "POST":
            accept = request.headers.get("Accept", "")
            accept = accept.split(",")[0]
            if accept == "text/event-stream":
                return await self.handle_sse_request(request)
            return await self.graphql_http_server(request)

        return self.handle_not_allowed_method(request)

    async def render_explorer(self, request: Request, explorer: Explorer) -> Response:
        """Return a HTML response with GraphQL explorer.

        # Required arguments:

        `request`: the `Request` instance from Starlette or FastAPI.

        `explorer`: an `Explorer` instance that implements the
        `html(request: Request)` method which returns either the `str` with HTML
        or `None`. If explorer returns `None`, `405` method not allowed response
        is returned instead.
        """
        explorer_html = explorer.html(request)
        if isawaitable(explorer_html):
            explorer_html = await explorer_html
        if explorer_html:
            return HTMLResponse(explorer_html)

        return self.handle_not_allowed_method(request)

    async def graphql_http_server(self, request: Request) -> Response:
        """Handles the HTTP request with GraphQL query.

        Extracts GraphQL query data from requests and then executes it using
        the `execute_graphql_query` method.

        Returns the JSON response from Sta

        If request's data was invalid or missing, plaintext response with
        error message and 400 status code is returned instead.

        # Required arguments:

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        try:
            data = await self.extract_data_from_request(request)
        except HttpError as error:
            return PlainTextResponse(
                error.message or error.status, status_code=HTTPStatus.BAD_REQUEST
            )

        success, result = await self.execute_graphql_query(request, data)
        return await self.create_json_response(request, result, success)

    async def extract_data_from_request(self, request: Request) -> Union[dict, list]:
        """Extracts GraphQL request data from request.

        Returns a `dict` or `list` with GraphQL query data that was not yet validated.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        content_type = request.headers.get("Content-Type", "")
        content_type = content_type.split(";")[0]

        if content_type == DATA_TYPE_JSON:
            return await self.extract_data_from_json_request(request)
        if content_type == DATA_TYPE_MULTIPART:
            return await self.extract_data_from_multipart_request(request)
        if (
            request.method == "GET"
            and self.execute_get_queries
            and request.query_params.get("query")
        ):
            return self.extract_data_from_get_request(request)

        raise HttpBadRequestError(
            f"Posted content must be of type {DATA_TYPE_JSON} or {DATA_TYPE_MULTIPART}"
        )

    async def extract_data_from_json_request(self, request: Request) -> dict:
        """Extracts GraphQL data from JSON request.

        Returns a `dict` with GraphQL query data that was not yet validated.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        try:
            return await request.json()
        except (TypeError, ValueError) as ex:
            raise HttpBadRequestError("Request body is not a valid JSON") from ex

    async def extract_data_from_multipart_request(
        self, request: Request
    ) -> Union[dict, list]:
        """Extracts GraphQL data from `multipart/form-data` request.

        Returns an unvalidated `dict` or `list` with GraphQL query data.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        try:
            request_body = await request.form()
        except ValueError as ex:
            raise HttpBadRequestError(
                "Request body is not a valid multipart/form-data"
            ) from ex

        try:
            operations = json.loads(cast(Any, request_body.get("operations")))
        except (TypeError, ValueError) as ex:
            raise HttpBadRequestError(
                "Request 'operations' multipart field is not a valid JSON"
            ) from ex
        try:
            files_map = json.loads(cast(Any, request_body.get("map")))
        except (TypeError, ValueError) as ex:
            raise HttpBadRequestError(
                "Request 'map' multipart field is not a valid JSON"
            ) from ex

        request_files = {
            key: value
            for key, value in request_body.items()
            if isinstance(value, UploadFile)
        }

        return combine_multipart_data(operations, files_map, request_files)

    def extract_data_from_get_request(self, request: Request) -> dict:
        """Extracts GraphQL data from GET request's querystring.

        Returns a `dict` with GraphQL query data that was not yet validated.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        query = request.query_params["query"].strip()
        operation_name = request.query_params.get("operationName", "").strip()
        variables = request.query_params.get("variables", "").strip()

        clean_variables = None

        if variables:
            try:
                clean_variables = json.loads(variables)
            except (TypeError, ValueError) as ex:
                raise HttpBadRequestError(
                    "Variables query arg is not a valid JSON"
                ) from ex

        return {
            "query": query,
            "operationName": operation_name or None,
            "variables": clean_variables,
        }

    async def execute_graphql_query(
        self,
        request: Any,
        data: Any,
        *,
        context_value: Any = None,
        query_document: Optional[DocumentNode] = None,
    ) -> GraphQLResult:
        """Executes GraphQL query from `request` and returns `GraphQLResult`.

        Creates GraphQL `ContextValue`, initializes extensions and middlewares,
        then runs the `graphql` function from Ariadne to execute the query.

        # Requires arguments

        `request`: the `Request` instance from Starlette or FastAPI.

        `data`: a GraphQL data.

        # Optional arguments

        `context_value`: a `ContextValue` for this request.

        `query_document`: an already parsed GraphQL query. Setting this option
        will prevent `graphql` from parsing `query` string from `data` second time.
        """
        if context_value is None:
            context_value = await self.get_context_for_request(request, data)

        extensions = await self.get_extensions_for_request(request, context_value)
        middleware = await self.get_middleware_for_request(request, context_value)

        if self.schema is None:
            raise TypeError("schema is not set, call configure method to initialize it")

        if isinstance(request, Request):
            require_query = request.method == "GET"
        else:
            require_query = False

        return await graphql(
            self.schema,
            data,
            context_value=context_value,
            root_value=self.root_value,
            query_parser=self.query_parser,
            query_validator=self.query_validator,
            query_document=query_document,
            validation_rules=self.validation_rules,
            require_query=require_query,
            debug=self.debug,
            introspection=self.introspection,
            logger=self.logger,
            error_formatter=self.error_formatter,
            extensions=extensions,
            middleware=middleware,
            middleware_manager_class=self.middleware_manager_class,
            execution_context_class=self.execution_context_class,
        )

    async def get_extensions_for_request(
        self, request: Any, context: Optional[ContextValue]
    ) -> ExtensionList:
        """Returns extensions to use when handling the GraphQL request.

        Returns `ExtensionList`, a list of extensions to use or `None`.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.

        `context`: a `ContextValue` for this request.
        """
        if callable(self.extensions):
            extensions = self.extensions(request, context)
            if isawaitable(extensions):
                extensions = await extensions  # type: ignore
            return extensions
        return self.extensions

    async def get_middleware_for_request(
        self, request: Any, context: Optional[ContextValue]
    ) -> MiddlewareList:
        """Returns GraphQL middlewares to use when handling the GraphQL request.

        Returns `MiddlewareList`, a list of middlewares to use or `None`.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.

        `context`: a `ContextValue` for this request.
        """
        middleware = self.middleware
        if callable(middleware):
            middleware = middleware(request, context)
            if isawaitable(middleware):
                middleware = await middleware  # type: ignore
        if middleware:
            return cast(MiddlewareList, middleware)
        return None

    async def create_json_response(
        self,
        request: Request,  # pylint: disable=unused-argument
        result: dict,
        success: bool,
    ) -> Response:
        """Creates JSON response from GraphQL's query result.

        Returns Starlette's `JSONResponse` instance that's also compatible
        with FastAPI. If `success` is `True`, response's status code is 200.
        Status code 400 is used otherwise.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.

        `result`: a JSON-serializable `dict` with query result.

        `success`: a `bool` specifying if
        """
        status_code = HTTPStatus.OK if success else HTTPStatus.BAD_REQUEST
        return JSONResponse(result, status_code=status_code)

    def handle_not_allowed_method(self, request: Request):
        """Handles request for unsupported HTTP method.

        Returns 200 response for `OPTIONS` request and 405 response for other
        methods. All responses have empty body.

        # Required arguments

        `request`: the `Request` instance from Starlette or FastAPI.
        """
        allowed_methods = ["OPTIONS", "POST"]
        if self.introspection:
            allowed_methods.append("GET")
        allow_header = {"Allow": ", ".join(allowed_methods)}

        if request.method == "OPTIONS":
            return Response(headers=allow_header)

        return Response(status_code=HTTPStatus.METHOD_NOT_ALLOWED, headers=allow_header)

    async def handle_sse_request(self, request: Request) -> Response:
        """Handles the HTTP request with GraphQL Subscription query using Server-Sent Events.

        # Required arguments

        `request`: the starlette `Request` instance
        """

        try:
            data = await self.extract_data_from_request(request)
            query = await self.get_query_from_sse_request(request, data)

            if self.schema is None:
                raise TypeError(
                    "schema is not set, call configure method to initialize it"
                )

            validate_data(data)
            context_value = await self.get_context_for_request(request, data)
            return ServerSentEventResponse(
                generator=self.sse_subscribe_to_graphql(query, data, context_value)
            )
        except (HttpError, TypeError, GraphQLError) as error:
            log_error(error, self.logger)
            if not isinstance(error, GraphQLError):
                error_message = (
                    (error.message or error.status)
                    if isinstance(error, HttpError)
                    else str(error)
                )
                error = GraphQLError(error_message, original_error=error)
            return ServerSentEventResponse(
                generator=self.sse_generate_error_response([error])
            )

    async def sse_generate_error_response(
        self, errors: List[GraphQLError]
    ) -> AsyncGenerator[GraphQLServerSentEvent, Any]:
        """A Server-Sent Event response generator for the errors
        To be passed to a ServerSentEventResponse instance

        # Required arguments

        `errors`: a list of `GraphQLError` instances
        """

        yield GraphQLServerSentEvent(
            event="next", result=ExecutionResult(errors=errors)
        )
        yield GraphQLServerSentEvent(event="complete")

    async def sse_subscribe_to_graphql(
        self, query_document: DocumentNode, data: Any, context_value: Any
    ):
        """Main SSE subscription generator for the GraphQL query. Yields `GraphQLServerSentEvent` instances
        and is to be consumed by a `ServerSentEventResponse` instance

        # Required arguments

        `query_document`: an already parsed GraphQL query.

        `data`: a `dict` with query data (`query` string, optionally `operationName`
        string and `variables` dictionary).

        `context_value`: a context value to make accessible as 'context' attribute
        of second argument (`info`) passed to resolvers and source functions.
        """

        success, results = await subscribe(
            self.schema,  # type: ignore
            data,
            context_value=context_value,
            root_value=self.root_value,
            query_document=query_document,
            query_validator=self.query_validator,
            validation_rules=self.validation_rules,
            debug=self.debug,
            introspection=self.introspection,
            logger=self.logger,
            error_formatter=self.error_formatter,
        )

        if not success:
            if not isinstance(results, list):
                error_payload = cast(List[dict], [results])
            else:
                error_payload = results

            # This needs to be handled better, subscribe returns preformatted errors
            yield GraphQLServerSentEvent(
                event="next",
                result=ExecutionResult(
                    errors=[
                        GraphQLError(message=error.get("message"))
                        for error in error_payload
                    ]
                ),
            )
        else:
            results = cast(AsyncGenerator, results)
            try:
                async for result in results:
                    yield GraphQLServerSentEvent(event="next", result=result)
            except (Exception, GraphQLError) as error:
                if not isinstance(error, GraphQLError):
                    error = GraphQLError(str(error), original_error=error)
                    log_error(error, self.logger)
                yield GraphQLServerSentEvent(
                    event="next", result=ExecutionResult(errors=[error])
                )

        yield GraphQLServerSentEvent(event="complete")

    async def get_query_from_sse_request(
        self, request: Request, data: Any
    ) -> DocumentNode:
        """Extracts GraphQL query from SSE request.

        Returns a `DocumentNode` with parsed query.

        # Required arguments

        `request`: the starlette `Request` instance

        `data`: an additional data parameter to potentially extract the query from
        """

        context_value = await self.get_context_for_request(request, data)
        return parse_query(context_value, self.query_parser, data)
